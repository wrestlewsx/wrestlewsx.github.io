---
layout: post
title: C++流操作
category: 技术
tags: C++
description: 详细记录C++中难以理解的流操作以及错误解决
---
### Ｃ++流的使用(续)

## 文件I/O
   <P> 常用的基本方法是 `open()`,`c_str()`,`is_open()` 分别时连接文件,转为Ｃ风格字符串,是否连接文件成功 </P>
   <pre><code>
   #include `<fstream>` //此头文件已经包含了iostream
   ...
   string cppstr1 = "input.txt", cppstr2 = "output.txt";
   ...
   ifstream fin;      //任意命名
   ofstream fout;
   fin.open(cppstr1.`c_str()`);
   if(!fin.`is_open()`)
   {
     cerr << "...";
     return -1;
   }
   fout.open();
   ...
   </code></pre>
   <p> 使用命令行参数的使用 </p>
   <p>`int main(int argc, char* argv[])` 式中的参数很多人既熟悉又陌生,第一个参数代表参数个数(包括自身)</p>
   <p> 第二个参数argv的意义在于使用某个参数的名字,以字符串的形式,举个栗子 </p>
   <pre><code>  
   #include ...
   ...
   int main(int argc, char* argv[])
   {
     for(int file = 1;file < argc;++file) //file为 0 时输出的是该命令或者可执行文件的名称
         cout << argv[file];              //argv[file]的类型为char*, 即为一个字符串,内容
                                          //为参数的名字,argc代表总参数个数+1
   }
   </code></pre>
   <p> 假设上面的程序经过编译,在Liunx下实验则为(Windows下请打开命令提示符模式(Win+R,输入cmd,回车后打开),后续操作相同) </p>
   `~$ a.out file1 file2`</br>
   <strong> 其中 argv[1] == "file1", argv[2] == "file2" argv[0] == "a.out" </strong></br> 
   <p> 文件I/O的模式 mode </p>
   <pre><code>
   //接上上个程序
   fin.open(cppstr1.`c_str()`,mode);//mode代表模式,后面介绍
   ifstream fin2(cppstr2.`c_str()`,mode);//也可以使用构造函数的方式
   ofstream fout2(...);//ofstream的模式多于ifstream
   </pre></code>
   <p>
   <strong>下面模式可以与Ｃ中的I/O模式对应</strong></br>
   `ios_base::in`   //此mode适用于ifstream类型,用于打开并读取文件</br>
   `ios_base::out`  //打开文件,并写入</br>
   `ios_base::trunc`//如果文件存在则,截断文件,ofstream的构造函数默认使用 `ios_base::out|ios_base::turnc`</br>
   `ios_base::app`  //打开文件,追加到文件尾写入</br>
   `ios_base::ate`  //打开文件,并移动到文件尾</br>
   <strong> 符号 `|` ,代表或,该运算符两端的操作都使用 </strong>
   </p>
